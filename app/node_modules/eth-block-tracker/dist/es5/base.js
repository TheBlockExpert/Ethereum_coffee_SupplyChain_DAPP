'use strict';

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EthQuery = require('eth-query');
var pify = require('pify');
var SafeEventEmitter = require('safe-event-emitter');

var sec = 1000;

var calculateSum = function calculateSum(accumulator, currentValue) {
  return accumulator + currentValue;
};
var blockTrackerEvents = ['sync', 'latest'];

var BaseBlockTracker = function (_SafeEventEmitter) {
  _inherits(BaseBlockTracker, _SafeEventEmitter);

  //
  // public
  //

  function BaseBlockTracker() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BaseBlockTracker);

    // config
    var _this = _possibleConstructorReturn(this, (BaseBlockTracker.__proto__ || Object.getPrototypeOf(BaseBlockTracker)).call(this));

    _this._blockResetDuration = opts.blockResetDuration || 20 * sec;
    // state
    _this._blockResetTimeout;
    _this._currentBlock = null;
    _this._isRunning = false;
    // bind functions for internal use
    _this._onNewListener = _this._onNewListener.bind(_this);
    _this._onRemoveListener = _this._onRemoveListener.bind(_this);
    _this._resetCurrentBlock = _this._resetCurrentBlock.bind(_this);
    // listen for handler changes
    _this._setupInternalEvents();
    return _this;
  }

  _createClass(BaseBlockTracker, [{
    key: 'isRunning',
    value: function isRunning() {
      return this._isRunning;
    }
  }, {
    key: 'getCurrentBlock',
    value: function getCurrentBlock() {
      return this._currentBlock;
    }
  }, {
    key: 'getLatestBlock',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var _this2 = this;

        var latestBlock;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!this._currentBlock) {
                  _context.next = 2;
                  break;
                }

                return _context.abrupt('return', this._currentBlock);

              case 2:
                _context.next = 4;
                return new Promise(function (resolve) {
                  return _this2.once('latest', resolve);
                });

              case 4:
                latestBlock = _context.sent;
                return _context.abrupt('return', latestBlock);

              case 6:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getLatestBlock() {
        return _ref.apply(this, arguments);
      }

      return getLatestBlock;
    }()

    // dont allow module consumer to remove our internal event listeners

  }, {
    key: 'removeAllListeners',
    value: function removeAllListeners(eventName) {
      // perform default behavior, preserve fn arity
      if (eventName) {
        _get(BaseBlockTracker.prototype.__proto__ || Object.getPrototypeOf(BaseBlockTracker.prototype), 'removeAllListeners', this).call(this, eventName);
      } else {
        _get(BaseBlockTracker.prototype.__proto__ || Object.getPrototypeOf(BaseBlockTracker.prototype), 'removeAllListeners', this).call(this);
      }
      // re-add internal events
      this._setupInternalEvents();
      // trigger stop check just in case
      this._onRemoveListener();
    }

    //
    // to be implemented in subclass
    //

  }, {
    key: '_start',
    value: function _start() {
      // default behavior is noop
    }
  }, {
    key: '_end',
    value: function _end() {}
    // default behavior is noop


    //
    // private
    //

  }, {
    key: '_setupInternalEvents',
    value: function _setupInternalEvents() {
      // first remove listeners for idempotence
      this.removeListener('newListener', this._onNewListener);
      this.removeListener('removeListener', this._onRemoveListener);
      // then add them
      this.on('newListener', this._onNewListener);
      this.on('removeListener', this._onRemoveListener);
    }
  }, {
    key: '_onNewListener',
    value: function _onNewListener(eventName, handler) {
      // `newListener` is called *before* the listener is added
      if (!blockTrackerEvents.includes(eventName)) return;
      this._maybeStart();
    }
  }, {
    key: '_onRemoveListener',
    value: function _onRemoveListener(eventName, handler) {
      // `removeListener` is called *after* the listener is removed
      if (this._getBlockTrackerEventCount() > 0) return;
      this._maybeEnd();
    }
  }, {
    key: '_maybeStart',
    value: function _maybeStart() {
      if (this._isRunning) return;
      this._isRunning = true;
      // cancel setting latest block to stale
      this._cancelBlockResetTimeout();
      this._start();
    }
  }, {
    key: '_maybeEnd',
    value: function _maybeEnd() {
      if (!this._isRunning) return;
      this._isRunning = false;
      this._setupBlockResetTimeout();
      this._end();
    }
  }, {
    key: '_getBlockTrackerEventCount',
    value: function _getBlockTrackerEventCount() {
      var _this3 = this;

      return blockTrackerEvents.map(function (eventName) {
        return _this3.listenerCount(eventName);
      }).reduce(calculateSum);
    }
  }, {
    key: '_newPotentialLatest',
    value: function _newPotentialLatest(newBlock) {
      var currentBlock = this._currentBlock;
      // only update if blok number is higher
      if (currentBlock && hexToInt(newBlock) <= hexToInt(currentBlock)) return;
      this._setCurrentBlock(newBlock);
    }
  }, {
    key: '_setCurrentBlock',
    value: function _setCurrentBlock(newBlock) {
      var oldBlock = this._currentBlock;
      this._currentBlock = newBlock;
      this.emit('latest', newBlock);
      this.emit('sync', { oldBlock: oldBlock, newBlock: newBlock });
    }
  }, {
    key: '_setupBlockResetTimeout',
    value: function _setupBlockResetTimeout() {
      // clear any existing timeout
      this._cancelBlockResetTimeout();
      // clear latest block when stale
      this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
      // nodejs - dont hold process open
      if (this._blockResetTimeout.unref) {
        this._blockResetTimeout.unref();
      }
    }
  }, {
    key: '_cancelBlockResetTimeout',
    value: function _cancelBlockResetTimeout() {
      clearTimeout(this._blockResetTimeout);
    }
  }, {
    key: '_resetCurrentBlock',
    value: function _resetCurrentBlock() {
      this._currentBlock = null;
    }
  }]);

  return BaseBlockTracker;
}(SafeEventEmitter);

module.exports = BaseBlockTracker;

function hexToInt(hexInt) {
  return Number.parseInt(hexInt, 16);
}